---
title: Fibers for Games
layout: blogpost
author: James Keats
selectedurl: Blog
tags: code, architecture, multithreading
description: Have you ever felt that normal multithreading isn't complicated enough?
---

Using fibers for game development is something that, like many other systems programmers, I've been fascinated by ever since seeing Naughty Dog's 2015 GDC talk: [Parallelizing the Naughty Dog Engine Using Fibers](https://archive.org/details/GDC2015Gyrling_201508). I would recommend that anyone interested in having as many tools in their multithreading belt as possible give it a watch.

I'll provide a very brief overview of what fibers actually are here and what makes them interesting to me. Fibers, sometimes referred to as green threads, user-space threads, virtual threads, and a litany of other names, are threads of execution which are "scheduled" in user space. Via user-space calls, they can be suspended (or "yielded") and resumed manually. The article [Fibers, Oh My](https://graphitemaster.github.io/fibers/) by Dale Weiler contains a great explanation of preemptive vs cooperatively scheduled execution, although it contains a few points which I consider to be mistakes or errors and items which are described in a very prescriptivist way which in actuality I think are use-case dependent. I'll address some of that below. However, the discussion on scheduling is spot-on, and I'll quote it here:

> Most people familiar with threads know that you don’t have to **yield** to other threads to allow them to run. This is because most operating systems (OS) schedule threads **preemptively**. [...] This is possible because the OS will decide at [calls to IO, sleeps, waits, and interrupts] to save all the relevant state of that thread then resume some other thread, the idea being that when this thread can run again, the OS can reinstate that thread and continue executing it like nothing ever happened
>
> [...]
>
> This idea of fibers yielding to each other is what is known as cooperative scheduling. Fibers effectively move the idea of context switching from kernel-space to user-space and then make those switches a fundamental part of computation, that is, they’re a deliberate and explicitly done thing, by the fibers themselves.
> 
> - [Fibers, Oh My!](https://graphitemaster.github.io/fibers/) by Dale Weiler

In Naughty Dog's talk, there are a few different components of their engine that they touch on: the actual fiber resource management and scheduling system itself (very briefly), synchronization between fibers which they do exclusively via counters and "wait for value" semantics, and then a relatively in-depth look into how they manage the concept of "frames" within this system primarily for resource management, allowing them to run rendering work for one frame simultaneously with game logic for another frame.

The part that they are probably the most sparse about is the actual management of the fibers. I think in part this is because they are using Sony's (proprietary) API for most of the low-level work. This gets skipped over because it isn't really important to the point of the talk, it's covered by NDA, and it's irrelevant for anyone developing for other platforms. Of course, if you go digging, you will find that APIs for fibers exist on other platforms as well, although they don't necessarily allow you to do all the things that are mentioned in this talk. For example, the Windows API has `::CreateFiber` and `::SwitchToFiber`. These are functions which could be used to create a similar system, but we would be unable to use our own memory management for stack space. Depending on your use case, it also spends cycles modifying and saving state which you might not care about. (Of course, the Windows API also knows Windows best... if you fail to modify or save some of the state that they do, you may find random system calls crash or behave unexpectedly).

The main thing that intrigues me about fibers is not just the multithreading capability in and of itself, however. I have written thread pools before and while there were definitely pain points involved with scheduling, it was not very common to want to yield to other work purely for scheduling in-and-of itself. The OS typically does a fine enough job when given sleeps and event waits. What is most interesting to me is the ability to write code which functions as a state machine for "free", i.e. without actually having to write huge "state" enums and structures that track the data needed to resume execution in the right place and so on. This is a real pain for systems in games which need to amortize their work 